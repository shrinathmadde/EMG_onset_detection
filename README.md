# EMG_onset_detection
# EMG Onset Detection using Deep Learning

This project explores two different deep learning models to detect the onset of muscle activation from continuous Electromyography (EMG) data. The models are trained on the same dataset, which is prepared using a common data preparation script.

## Project Overview

The primary goal is to identify burst-like activity in EMG signals, which corresponds to muscle contraction. This is tackled using two distinct neural network architectures:

1.  **Model 1 (1D CNN)**: A 1D Convolutional Neural Network (CNN) built with PyTorch that performs semantic segmentation on raw EMG signal epochs.
2.  **Model 2 (DEMANN)**: A fully-connected neural network based on the DEMANN architecture, built with TensorFlow, which uses hand-crafted features extracted from the EMG signal.

Both models learn to classify time points or windows as either "activity" (1) or "no activity" (0).

## Folder Structure

All necessary files for this project are organized into two main folders:


├── Model_1/
│   ├── label.ipynb       # Notebook for data preparation and labeling (used by both models)
│   └── main.ipynb        # Notebook for Model 1 (1D CNN) training and prediction
│
└── Model_2/
├── model.py                  # Defines the DEMANN model architecture
├── evaluation.py             # Scripts for evaluating prediction performance
└── demann_predict_fixed.py   # Script for feature extraction, training, and prediction for Model 2


## Workflow

The process is sequential, starting with a common data preparation step, followed by training and prediction using one of the two model approaches.

### 1. Data Preparation & Labeling (`Model_1/label.ipynb`)

This notebook is the **first step for both models**. It takes raw, continuous EMG data in `.fdt` format and processes it to create a labeled dataset suitable for training.

**Key Functions:**

* **Load EMG Data**: Scans a directory for `.fdt` files.
* **Channel Extraction**: Assumes a 4-channel setup (DI, OO, ZM, CS) and extracts the Zygomaticus Major (ZM) channel, which is used for analysis.
* **Epoching**: The continuous ZM signal is segmented into smaller, fixed-length windows (epochs of 435 samples).
* **Threshold-Based Labeling**: A simple thresholding algorithm is applied to each epoch to generate initial binary masks. These masks label each sample as either part of a muscle burst (1) or not (0).
* **Data Saving**: Each processed epoch and its corresponding labels are saved in two separate files:
    * An `.npz` file containing the raw signal data for the epoch.
    * A `.json` file containing the onset and offset labels.

### 2. Model Training & Prediction

After preparing the data, you can choose one of the following approaches to train a model.

---

### Approach 1: 1D CNN (`Model_1/main.ipynb`)

This notebook contains a PyTorch-based 1D CNN for onset detection.

**Key Components:**

* **`EMGDataset` Class**: A custom PyTorch `Dataset` that loads the `.npz` signal files and `.json` label files.
* **`EMGBurstDetector` Model**: A 1D CNN with several convolutional layers, BatchNorm, and Dropout, designed to learn features directly from the raw time-series EMG data.
* **Training**:
    * Trains the model using a Binary Cross-Entropy (BCE) loss function and the Adam optimizer.
    * Saves the trained model as `emg_burst_detector.pt`.
* **Prediction**:
    * Loads the trained model and runs inference on new data.
    * Generates and saves PNG images visualizing the EMG signal with the model's predicted activation areas highlighted.
    * Saves onset/offset points for predictions to a `.json` file.

---

### Approach 2: DEMANN (`Model_2/`)

This approach uses a simpler, fully-connected network that relies on feature engineering. The entire workflow is contained within the `demann_predict_fixed.py` script.

**Key Components:**

* **Feature Extraction**: Before training, the script extracts three key features from each EMG epoch:
    1.  **Linear Envelope (LE)**
    2.  **Root Mean Square (RMS)**
    3.  **Continuous Wavelet Transform (CWT)**
* **`create_demann_model` Function**: Defines a single-hidden-layer neural network using TensorFlow/Keras, as described in the DEMANN paper.
* **Training & Prediction**: The `demann_predict_fixed.py` script handles both training and prediction.
    * It uses the `.npz` and `.json` files generated by `label.ipynb`.
    * It trains the model and saves the best version as `demann_model.h5`.
    * It then runs inference and saves prediction plots and a `prediction_results.json` file.
* **Evaluation**: The `evaluation.py` script provides functions to calculate performance metrics like precision, recall, F1-score, and Mean Absolute Error (MAE) for the onset/offset predictions.

## How to Use

#### Step 1: Prepare the Data

1.  Place your raw continuous EMG data files (`.fdt` extension) into a `continuous_EMG_data` directory (or update the path in `label.ipynb`).
2.  Open and run all cells in `Model_1/label.ipynb`. This will process the raw data and create a `training_data` directory containing the labeled `.npz` and `.json` files needed for both models.

#### Step 2: Choose and Run a Model

**For Model 1 (1D CNN):**

1.  Open and run the training cells in `Model_1/main.ipynb`. This will train the model and save `emg_burst_detector.pt`.
2.  Run the final cells in `main.ipynb` to load the trained model and generate predictions.

**For Model 2 (DEMANN):**

1.  The `demann_predict_fixed.py` script is designed to be run from the command line. Open your terminal and navigate to the `Model_2` directory.
2.  **To train and predict:**
    ```bash
    python demann_predict_fixed.py --json_labels_path /path/to/your/training_data/all_burst_labels.json --output_dir demann_results --mode both
    ```
3.  **To only run predictions with a pre-trained model:**
    ```bash
    python demann_predict_fixed.py --json_labels_path /path/to/your/training_data/all_burst_labels.json --output_dir prediction_run --mode predict --model_path /path/to/your/demann_model.h5
    ```

## Dependencies

This project uses the following Python libraries:

* PyTorch
* TensorFlow
* NumPy
* Matplotlib
* SciPy
* tqdm
* PyWavelets (`pywt`)
